// Generated by CoffeeScript 1.9.3
(function() {
  var BrowserWindow, EventEmitter, Menu, MenuItem, applicationMenu, bindings, generateGroupId, indexOfItemById, indexToInsertByPosition, nextGroupId, v8Util;

  BrowserWindow = require('browser-window');

  EventEmitter = require('events').EventEmitter;

  MenuItem = require('menu-item');

  v8Util = process.atomBinding('v8_util');

  bindings = process.atomBinding('menu');

  nextGroupId = 0;

  generateGroupId = function(items, pos) {
    var i, item, j, k, ref, ref1, ref2;
    if (pos > 0) {
      for (i = j = ref = pos - 1; ref <= 0 ? j <= 0 : j >= 0; i = ref <= 0 ? ++j : --j) {
        item = items[i];
        if (item.type === 'radio') {
          return item.groupId;
        }
        if (item.type === 'separator') {
          break;
        }
      }
    } else if (pos < items.length) {
      for (i = k = ref1 = pos, ref2 = items.length - 1; ref1 <= ref2 ? k <= ref2 : k >= ref2; i = ref1 <= ref2 ? ++k : --k) {
        item = items[i];
        if (item.type === 'radio') {
          return item.groupId;
        }
        if (item.type === 'separator') {
          break;
        }
      }
    }
    return ++nextGroupId;
  };

  indexOfItemById = function(items, id) {
    var i, item, j, len;
    for (i = j = 0, len = items.length; j < len; i = ++j) {
      item = items[i];
      if (item.id === id) {
        return i;
      }
    }
    return -1;
  };

  indexToInsertByPosition = function(items, position) {
    var id, insertIndex, query, ref;
    if (!position) {
      return items.length;
    }
    ref = position.split('='), query = ref[0], id = ref[1];
    insertIndex = indexOfItemById(items, id);
    if (insertIndex === -1 && query !== 'endof') {
      console.warn("Item with id '" + id + "' is not found");
      return items.length;
    }
    switch (query) {
      case 'after':
        insertIndex++;
        break;
      case 'endof':
        if (insertIndex === -1) {
          items.push({
            id: id,
            type: 'separator'
          });
          insertIndex = items.length - 1;
        }
        insertIndex++;
        while (insertIndex < items.length && items[insertIndex].type !== 'separator') {
          insertIndex++;
        }
    }
    return insertIndex;
  };

  Menu = bindings.Menu;

  Menu.prototype.__proto__ = EventEmitter.prototype;

  Menu.prototype._init = function() {
    this.commandsMap = {};
    this.groupsMap = {};
    this.items = [];
    return this.delegate = {
      isCommandIdChecked: (function(_this) {
        return function(commandId) {
          var ref;
          return (ref = _this.commandsMap[commandId]) != null ? ref.checked : void 0;
        };
      })(this),
      isCommandIdEnabled: (function(_this) {
        return function(commandId) {
          var ref;
          return (ref = _this.commandsMap[commandId]) != null ? ref.enabled : void 0;
        };
      })(this),
      isCommandIdVisible: (function(_this) {
        return function(commandId) {
          var ref;
          return (ref = _this.commandsMap[commandId]) != null ? ref.visible : void 0;
        };
      })(this),
      getAcceleratorForCommandId: (function(_this) {
        return function(commandId) {
          var ref;
          return (ref = _this.commandsMap[commandId]) != null ? ref.accelerator : void 0;
        };
      })(this),
      getIconForCommandId: (function(_this) {
        return function(commandId) {
          var ref;
          return (ref = _this.commandsMap[commandId]) != null ? ref.icon : void 0;
        };
      })(this),
      executeCommand: (function(_this) {
        return function(commandId) {
          var ref;
          return (ref = _this.commandsMap[commandId]) != null ? ref.click(BrowserWindow.getFocusedWindow()) : void 0;
        };
      })(this),
      menuWillShow: (function(_this) {
        return function() {
          var checked, group, id, j, len, radioItem, ref, results;
          ref = _this.groupsMap;
          results = [];
          for (id in ref) {
            group = ref[id];
            checked = false;
            for (j = 0, len = group.length; j < len; j++) {
              radioItem = group[j];
              if (!radioItem.checked) {
                continue;
              }
              checked = true;
              break;
            }
            if (!checked) {
              results.push(v8Util.setHiddenValue(group[0], 'checked', true));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this)
    };
  };

  Menu.prototype.popup = function(window, x, y) {
    if ((window != null ? window.constructor : void 0) !== BrowserWindow) {
      throw new TypeError('Invalid window');
    }
    if ((x != null) && (y != null)) {
      return this._popupAt(window, x, y);
    } else {
      return this._popup(window);
    }
  };

  Menu.prototype.append = function(item) {
    return this.insert(this.getItemCount(), item);
  };

  Menu.prototype.insert = function(pos, item) {
    var base, name;
    if ((item != null ? item.constructor : void 0) !== MenuItem) {
      throw new TypeError('Invalid item');
    }
    switch (item.type) {
      case 'normal':
        this.insertItem(pos, item.commandId, item.label);
        break;
      case 'checkbox':
        this.insertCheckItem(pos, item.commandId, item.label);
        break;
      case 'separator':
        this.insertSeparator(pos);
        break;
      case 'submenu':
        this.insertSubMenu(pos, item.commandId, item.label, item.submenu);
        break;
      case 'radio':
        item.overrideReadOnlyProperty('groupId', generateGroupId(this.items, pos));
        if ((base = this.groupsMap)[name = item.groupId] == null) {
          base[name] = [];
        }
        this.groupsMap[item.groupId].push(item);
        v8Util.setHiddenValue(item, 'checked', item.checked);
        Object.defineProperty(item, 'checked', {
          enumerable: true,
          get: function() {
            return v8Util.getHiddenValue(item, 'checked');
          },
          set: (function(_this) {
            return function(val) {
              var j, len, otherItem, ref;
              ref = _this.groupsMap[item.groupId];
              for (j = 0, len = ref.length; j < len; j++) {
                otherItem = ref[j];
                if (otherItem !== item) {
                  v8Util.setHiddenValue(otherItem, 'checked', false);
                }
              }
              return v8Util.setHiddenValue(item, 'checked', true);
            };
          })(this)
        });
        this.insertRadioItem(pos, item.commandId, item.label, item.groupId);
    }
    if (item.sublabel != null) {
      this.setSublabel(pos, item.sublabel);
    }
    if (item.icon != null) {
      this.setIcon(pos, item.icon);
    }
    if (item.role != null) {
      this.setRole(pos, item.role);
    }
    item.overrideReadOnlyProperty('menu', this);
    this.items.splice(pos, 0, item);
    return this.commandsMap[item.commandId] = item;
  };

  Menu.prototype._callMenuWillShow = function() {
    var item, j, len, ref, ref1, results;
    if ((ref = this.delegate) != null) {
      ref.menuWillShow();
    }
    ref1 = this.items;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      item = ref1[j];
      if (item.submenu != null) {
        results.push(item.submenu._callMenuWillShow());
      }
    }
    return results;
  };

  applicationMenu = null;

  Menu.setApplicationMenu = function(menu) {
    var j, len, results, w, windows;
    if (!(menu === null || menu.constructor === Menu)) {
      throw new TypeError('Invalid menu');
    }
    applicationMenu = menu;
    if (process.platform === 'darwin') {
      if (menu === null) {
        return;
      }
      menu._callMenuWillShow();
      return bindings.setApplicationMenu(menu);
    } else {
      windows = BrowserWindow.getAllWindows();
      results = [];
      for (j = 0, len = windows.length; j < len; j++) {
        w = windows[j];
        results.push(w.setMenu(menu));
      }
      return results;
    }
  };

  Menu.getApplicationMenu = function() {
    return applicationMenu;
  };

  Menu.sendActionToFirstResponder = bindings.sendActionToFirstResponder;

  Menu.buildFromTemplate = function(template) {
    var insertIndex, item, j, k, key, len, len1, menu, menuItem, positionedTemplate, value;
    if (!Array.isArray(template)) {
      throw new TypeError('Invalid template for Menu');
    }
    positionedTemplate = [];
    insertIndex = 0;
    for (j = 0, len = template.length; j < len; j++) {
      item = template[j];
      if (item.position) {
        insertIndex = indexToInsertByPosition(positionedTemplate, item.position);
      } else {
        insertIndex++;
      }
      positionedTemplate.splice(insertIndex, 0, item);
    }
    menu = new Menu;
    for (k = 0, len1 = positionedTemplate.length; k < len1; k++) {
      item = positionedTemplate[k];
      if (typeof item !== 'object') {
        throw new TypeError('Invalid template for MenuItem');
      }
      if (item.submenu != null) {
        item.submenu = Menu.buildFromTemplate(item.submenu);
      }
      menuItem = new MenuItem(item);
      for (key in item) {
        value = item[key];
        if (menuItem[key] == null) {
          menuItem[key] = value;
        }
      }
      menu.append(menuItem);
    }
    return menu;
  };

  module.exports = Menu;

}).call(this);
